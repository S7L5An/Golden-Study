import type { AuthDataMap, TelegramUserData } from './utils';
export interface AuthDataValidatorOptions {
    /**
     * The bot token to be used for validating the data.
     *
     * If you don't pass this here, you'll need to set it later using `setBotToken()`.
     */
    botToken?: string;
    /**
     * The crypto object to be used for validating the data
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto
     */
    subtleCrypto?: SubtleCrypto;
    /**
     * The encoder to be used for encoding the data
     */
    encoder?: TextEncoder;
    /**
     * The time in seconds after which the data should be considered invalid
     *
     * @default 86400 (1 day)
     */
    inValidateDataAfter?: number;
    /**
     * Whether to throw an error if the data is empty/incomplete
     *
     * @default true
     */
    throwIfEmptyData?: boolean;
}
/**
 * Validates the data sent by Telegram Login Widget
 *
 * @see https://core.telegram.org/widgets/login#checking-authorization
 */
export declare class AuthDataValidator {
    protected botToken: string;
    protected crypto: SubtleCrypto;
    protected encoder: TextEncoder;
    protected inValidateDataAfter: number;
    protected throwIfEmptyData: boolean;
    constructor({ botToken, subtleCrypto, encoder, inValidateDataAfter, throwIfEmptyData, }?: AuthDataValidatorOptions);
    /**
     * Ensure that we have a valid subtle crypto object
     *
     * @param {SubtleCrypto} [subtleCrypto] - The SubtleCrypto instance provided.
     * @returns The subtle crypto object.
     */
    protected assertValidCrypto(subtleCrypto?: SubtleCrypto): any;
    /**
     * Sets the bot token to be used for validating the data
     *
     * @param {string} botToken The bot token to be used
     */
    setBotToken(botToken: string): this;
    /**
     * Sets the crypto to be used for validating the data
     *
     * @param {SubtleCrypto} subtleCrypto The crypto to be used
     */
    setCrypto(subtleCrypto: SubtleCrypto): this;
    /**
     * Sets the encoder to be used for encoding the data
     *
     * @param {TextEncoder} encoder The encoder to be used
     */
    setEncoder(encoder: TextEncoder): this;
    /**
     * This function sets the inValidateDataAfter property of the class
     * which is the number of seconds after which the data is considered invalid.
     *
     * @param {number} inValidateDataAfter - The number of seconds after which the data is considered
     * invalid.
     */
    setInValidateDataAfter(inValidateDataAfter: number): this;
    /**
     * This function sets the throwIfEmptyData property of the class.
     *
     * @param {boolean} throwIfEmptyData - Whether to throw an error if the data is empty/incomplete.
     */
    setThrowIfEmptyData(throwIfEmptyData: boolean): this;
    /**
     * It takes a map of auth data received from Telegram, and returns the data if it's valid
     *
     * @see https://core.telegram.org/widgets/login#checking-authorization
     *
     * @param {AuthDataMap} authDataMap The data to be validated
     * @returns The validated data.
     */
    validate<T extends {
        id: number | string;
    } = TelegramUserData>(authDataMap: AuthDataMap): Promise<T>;
    /**
     * Whether the data is expired or not as per the `inValidateDataAfter` property.
     *
     * @param {AuthDataMap} authData - AuthDataMap - The auth data that was passed.
     * @returns A boolean value.
     */
    protected hasDataExpired(authData: AuthDataMap): boolean;
    /**
     * It checks if the bot token is set.
     */
    protected assertBotToken(): void;
    /**
     * If the hash, auth_date, and id or user are not present, throw an error.
     *
     * @param {AuthDataMap} authDataMap - A Map object containing the data.
     */
    protected assertDataShape(authDataMap: AuthDataMap): void;
    /**
     * It takes a bot token and returns a secret key based on whether the data is from
     * a normal Telegram login or from a web app.
     *
     * @param {boolean} [isWebAppData] whether the secret key is from Telegram web app.
     * @returns A secret key
     */
    protected getSecretKey(isWebAppData?: boolean): Promise<CryptoKey>;
    /**
     * It takes a map of key-value pairs, sorts the keys, and then joins the key-value pairs into a string
     * with a new line between each pair.
     *
     * @param {AuthDataMap} authDataMap - The map of key-value pairs to be sorted and joined.
     *
     * @returns A string of the authDataMap keys and values, sorted alphabetically.
     */
    protected getFinalDataStr(authDataMap: AuthDataMap): string;
}
//# sourceMappingURL=AuthDataValidator.d.ts.map